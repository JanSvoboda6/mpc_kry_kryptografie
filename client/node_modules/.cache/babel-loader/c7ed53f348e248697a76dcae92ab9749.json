{"ast":null,"code":"import Moment from \"moment\";\n\nconst getUniqueAddedFiles = (existingFiles, addedFiles, prefix) => {\n  const newFiles = addedFiles.map(file => {\n    let newKey = prefix;\n\n    if (prefix !== '' && prefix.substring(prefix.length - 1) !== '/') {\n      newKey += '/';\n    }\n\n    newKey += file.name;\n    return {\n      key: newKey,\n      size: file.size,\n      modified: +Moment().unix(),\n      data: file\n    };\n  });\n  const uniqueNewFiles = [];\n  newFiles.map(newFile => {\n    let fileAlreadyExists = false;\n    existingFiles.map(existingFile => {\n      if (existingFile.key === newFile.key) {\n        fileAlreadyExists = true;\n      }\n    });\n\n    if (!fileAlreadyExists) {\n      uniqueNewFiles.push(newFile);\n    }\n  });\n  return uniqueNewFiles;\n};\n\nconst deleteSelectedFolders = (existingFiles, keysOfFoldersToBeDeleted) => {\n  return existingFiles.filter(file => !shouldBeDeleted(file.key, keysOfFoldersToBeDeleted));\n};\n\nconst deleteSelectedFile = (existingFiles, keyOfFileToBeDeleted) => {\n  return existingFiles.filter(file => file.key !== keyOfFileToBeDeleted);\n};\n\nconst renameFile = (existingFiles, oldKey, newKey) => {\n  const unique = isFileKeyUnique(existingFiles, newKey);\n  let updatedFiles = [];\n  existingFiles.forEach(file => {\n    if (unique && file.key === oldKey) {\n      updatedFiles.push({ ...file,\n        key: newKey,\n        modified: +Moment()\n      });\n    } else {\n      updatedFiles.push(file);\n    }\n  });\n  return updatedFiles;\n};\n\nconst renameFolder = (existingFiles, oldKey, newKey) => {\n  const unique = isFolderKeyUnique(existingFiles, newKey);\n  let updatedFiles = [];\n  existingFiles.forEach(file => {\n    if (unique && file.key.substr(0, oldKey.length) === oldKey) {\n      updatedFiles.push({ ...file,\n        key: file.key.replace(oldKey, newKey),\n        modified: +Moment()\n      });\n    } else {\n      updatedFiles.push(file);\n    }\n  });\n  return updatedFiles;\n};\n\nconst isFileKeyUnique = (existingFiles, keyOfTheFile) => {\n  let unique = true;\n  existingFiles.forEach(file => {\n    if (file.key === keyOfTheFile) {\n      unique = false;\n      return;\n    }\n  });\n  return unique;\n};\n\nconst isFolderKeyUnique = (existingFiles, keyOfTheFolder) => {\n  let unique = true;\n  existingFiles.forEach(file => {\n    if (file.key.substr(0, keyOfTheFolder.length) === keyOfTheFolder) {\n      unique = false;\n    }\n  });\n  return unique;\n};\n\nconst shouldBeDeleted = (existingFileKey, keysOfFoldersToBeDeleted) => {\n  let shouldDelete = false;\n  keysOfFoldersToBeDeleted.forEach(keyOfFolderToBeDeleted => {\n    if (existingFileKey.substr(0, keyOfFolderToBeDeleted.length) === keyOfFolderToBeDeleted) {\n      shouldDelete = true;\n      return;\n    }\n  });\n  return shouldDelete;\n};\n\nexport default {\n  getUniqueAddedFiles,\n  deleteSelectedFolders,\n  deleteSelectedFile,\n  renameFile,\n  renameFolder\n};","map":{"version":3,"sources":["/Users/jan/dev/thesis/ml_runner/react/ml-runner/src/components/dataset/DatasetUtility.ts"],"names":["Moment","getUniqueAddedFiles","existingFiles","addedFiles","prefix","newFiles","map","file","newKey","substring","length","name","key","size","modified","unix","data","uniqueNewFiles","newFile","fileAlreadyExists","existingFile","push","deleteSelectedFolders","keysOfFoldersToBeDeleted","filter","shouldBeDeleted","deleteSelectedFile","keyOfFileToBeDeleted","renameFile","oldKey","unique","isFileKeyUnique","updatedFiles","forEach","renameFolder","isFolderKeyUnique","substr","replace","keyOfTheFile","keyOfTheFolder","existingFileKey","shouldDelete","keyOfFolderToBeDeleted"],"mappings":"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","sourcesContent":["import {FileInformation} from \"../../types\";\nimport Moment from \"moment\";\n\nconst getUniqueAddedFiles = (existingFiles: FileInformation[], addedFiles: File[], prefix: string): FileInformation[] => {\n    const newFiles: Array<FileInformation> = addedFiles.map((file) =>\n    {\n        let newKey = prefix\n        if (prefix !== '' && prefix.substring(prefix.length - 1) !== '/')\n        {\n            newKey += '/'\n        }\n        newKey += file.name\n        return {\n            key: newKey,\n            size: file.size,\n            modified: +Moment().unix(),\n            data: file\n        }\n    })\n\n    const uniqueNewFiles: Array<FileInformation> = [];\n\n    newFiles.map((newFile) =>\n    {\n        let fileAlreadyExists = false;\n        existingFiles.map((existingFile) =>\n        {\n            if (existingFile.key === newFile.key)\n            {\n                fileAlreadyExists = true;\n            }\n        })\n        if (!fileAlreadyExists)\n        {\n            uniqueNewFiles.push(newFile);\n        }\n    })\n\n    return uniqueNewFiles;\n}\n\nconst deleteSelectedFolders = (existingFiles: FileInformation[], keysOfFoldersToBeDeleted: string[]): FileInformation[] => {\n    return existingFiles.filter(file => !shouldBeDeleted(file.key, keysOfFoldersToBeDeleted));\n}\n\nconst deleteSelectedFile = (existingFiles: FileInformation[], keyOfFileToBeDeleted: string): FileInformation[] => {\n    return existingFiles.filter(file => file.key !== keyOfFileToBeDeleted);\n}\n\nconst renameFile = (existingFiles: FileInformation[], oldKey: string, newKey: string): FileInformation[] => {\n    const unique = isFileKeyUnique(existingFiles, newKey);\n    let updatedFiles: FileInformation[] = [];\n    existingFiles.forEach(file => {\n        if(unique && file.key === oldKey){\n            updatedFiles.push({\n                ...file,\n                key: newKey,\n                modified: +Moment(),\n            })\n        }else{\n            updatedFiles.push(file);\n        }\n    });\n    return updatedFiles;\n}\n\nconst renameFolder = (existingFiles: FileInformation[], oldKey: string, newKey: string): FileInformation[] => {\n    const unique = isFolderKeyUnique(existingFiles, newKey);\n    let updatedFiles: FileInformation[] = [];\n    existingFiles.forEach(file => {\n        if (unique && (file.key.substr(0, oldKey.length) === oldKey))\n        {\n            updatedFiles.push({\n                ...file,\n                key: file.key.replace(oldKey, newKey),\n                modified: +Moment(),\n            })\n        } else {\n            updatedFiles.push(file)\n        }\n    })\n    return  updatedFiles;\n}\n\nconst isFileKeyUnique = (existingFiles: FileInformation[], keyOfTheFile: string): boolean => {\n    let unique = true;\n    existingFiles.forEach(file => {\n        if(file.key === keyOfTheFile)\n        {\n            unique = false;\n            return;\n        }\n    })\n    return unique;\n}\n\nconst isFolderKeyUnique = (existingFiles: FileInformation[], keyOfTheFolder: string): boolean => {\n    let unique = true;\n    existingFiles.forEach(file => {\n        if (file.key.substr(0, keyOfTheFolder.length) === keyOfTheFolder)\n        {\n            unique = false;\n        }\n    })\n    return unique;\n}\n\nconst shouldBeDeleted = (existingFileKey: string, keysOfFoldersToBeDeleted: string[]): boolean => {\n    let shouldDelete = false;\n    keysOfFoldersToBeDeleted.forEach((keyOfFolderToBeDeleted) => {\n        if (existingFileKey.substr(0, keyOfFolderToBeDeleted.length) === keyOfFolderToBeDeleted)\n        {\n            shouldDelete = true;\n            return;\n        }\n    });\n    return shouldDelete;\n}\n\nexport default {getUniqueAddedFiles, deleteSelectedFolders, deleteSelectedFile, renameFile, renameFolder};"]},"metadata":{},"sourceType":"module"}