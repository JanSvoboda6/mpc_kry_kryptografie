{"ast":null,"code":"import Moment from \"moment\";\n\nconst getUniqueAddedFiles = (existingFiles, addedFiles, prefix) => {\n  const newFiles = addedFiles.map(file => {\n    let newKey = prefix;\n\n    if (prefix !== '' && prefix.substring(prefix.length - 1) !== '/') {\n      newKey += '/';\n    }\n\n    newKey += file.name;\n    return {\n      key: newKey,\n      size: file.size,\n      modified: +Moment().unix(),\n      data: file\n    };\n  });\n  const uniqueNewFiles = [];\n  newFiles.map(newFile => {\n    let fileAlreadyExists = false;\n    existingFiles.map(existingFile => {\n      if (existingFile.key === newFile.key) {\n        fileAlreadyExists = true;\n      }\n    });\n\n    if (!fileAlreadyExists) {\n      uniqueNewFiles.push(newFile);\n    }\n  });\n  return uniqueNewFiles;\n};\n\nconst deleteSelectedFolders = (existingFiles, keysOfFoldersToBeDeleted) => {\n  return existingFiles.filter(file => !shouldBeFolderDeleted(file.key, keysOfFoldersToBeDeleted));\n};\n\nconst deleteSelectedFiles = (existingFiles, keysOfFilesToBeDeleted) => {\n  return existingFiles.filter(file => !shouldBeFileDeleted(file.key, keysOfFilesToBeDeleted));\n};\n\nconst renameFile = (existingFiles, oldKey, newKey) => {\n  const unique = isFileKeyUnique(existingFiles, newKey);\n  let updatedFiles = [];\n  existingFiles.forEach(file => {\n    if (unique && file.key === oldKey) {\n      updatedFiles.push({ ...file,\n        key: newKey,\n        modified: +Moment()\n      });\n    } else {\n      updatedFiles.push(file);\n    }\n  });\n  return updatedFiles;\n};\n\nconst renameFolder = (existingFiles, oldKey, newKey) => {\n  const unique = isFolderKeyUnique(existingFiles, newKey);\n  let updatedFiles = [];\n  existingFiles.forEach(file => {\n    if (unique && file.key.substr(0, oldKey.length) === oldKey) {\n      updatedFiles.push({ ...file,\n        key: file.key.replace(oldKey, newKey),\n        modified: +Moment()\n      });\n    } else {\n      updatedFiles.push(file);\n    }\n  });\n  return updatedFiles;\n};\n\nconst isFileKeyUnique = (existingFiles, keyOfTheFile) => {\n  let unique = true;\n  existingFiles.forEach(file => {\n    if (file.key === keyOfTheFile) {\n      unique = false;\n      return;\n    }\n  });\n  return unique;\n};\n\nconst isFolderKeyUnique = (existingFiles, keyOfTheFolder) => {\n  let unique = true;\n  existingFiles.forEach(file => {\n    if (file.key.substr(0, keyOfTheFolder.length) === keyOfTheFolder) {\n      unique = false;\n    }\n  });\n  return unique;\n};\n\nconst shouldBeFolderDeleted = (existingFileKey, keysOfFoldersToBeDeleted) => {\n  let shouldDelete = false;\n  keysOfFoldersToBeDeleted.forEach(keyOfFolderToBeDeleted => {\n    if (existingFileKey.substr(0, keyOfFolderToBeDeleted.length) === keyOfFolderToBeDeleted) {\n      shouldDelete = true;\n      return;\n    }\n  });\n  return shouldDelete;\n};\n\nconst shouldBeFileDeleted = (existingFileKey, keysOfFilesToBeDeleted) => {\n  let shouldDelete = false;\n  keysOfFilesToBeDeleted.forEach(keyOfFileToBeDeleted => {\n    if (keyOfFileToBeDeleted === keyOfFileToBeDeleted) {\n      shouldDelete = true;\n      return;\n    }\n  });\n  return shouldDelete;\n};\n\nexport default {\n  getUniqueAddedFiles,\n  deleteSelectedFolders,\n  deleteSelectedFile,\n  renameFile,\n  renameFolder\n};","map":{"version":3,"sources":["/Users/jan/dev/thesis/ml_runner/react/ml-runner/src/components/dataset/DatasetUtility.ts"],"names":["Moment","getUniqueAddedFiles","existingFiles","addedFiles","prefix","newFiles","map","file","newKey","substring","length","name","key","size","modified","unix","data","uniqueNewFiles","newFile","fileAlreadyExists","existingFile","push","deleteSelectedFolders","keysOfFoldersToBeDeleted","filter","shouldBeFolderDeleted","deleteSelectedFiles","keysOfFilesToBeDeleted","shouldBeFileDeleted","renameFile","oldKey","unique","isFileKeyUnique","updatedFiles","forEach","renameFolder","isFolderKeyUnique","substr","replace","keyOfTheFile","keyOfTheFolder","existingFileKey","shouldDelete","keyOfFolderToBeDeleted","keyOfFileToBeDeleted","deleteSelectedFile"],"mappings":"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","sourcesContent":["import {FileInformation} from \"../../types\";\nimport Moment from \"moment\";\n\nconst getUniqueAddedFiles = (existingFiles: FileInformation[], addedFiles: File[], prefix: string): FileInformation[] => {\n    const newFiles: Array<FileInformation> = addedFiles.map((file) =>\n    {\n        let newKey = prefix\n        if (prefix !== '' && prefix.substring(prefix.length - 1) !== '/')\n        {\n            newKey += '/'\n        }\n        newKey += file.name\n        return {\n            key: newKey,\n            size: file.size,\n            modified: +Moment().unix(),\n            data: file\n        }\n    })\n\n    const uniqueNewFiles: Array<FileInformation> = [];\n\n    newFiles.map((newFile) =>\n    {\n        let fileAlreadyExists = false;\n        existingFiles.map((existingFile) =>\n        {\n            if (existingFile.key === newFile.key)\n            {\n                fileAlreadyExists = true;\n            }\n        })\n        if (!fileAlreadyExists)\n        {\n            uniqueNewFiles.push(newFile);\n        }\n    })\n\n    return uniqueNewFiles;\n}\n\nconst deleteSelectedFolders = (existingFiles: FileInformation[], keysOfFoldersToBeDeleted: string[]): FileInformation[] => {\n    return existingFiles.filter(file => !shouldBeFolderDeleted(file.key, keysOfFoldersToBeDeleted));\n}\n\nconst deleteSelectedFiles = (existingFiles: FileInformation[], keysOfFilesToBeDeleted: string[]): FileInformation[] => {\n    return existingFiles.filter(file => !shouldBeFileDeleted(file.key, keysOfFilesToBeDeleted));\n}\n\nconst renameFile = (existingFiles: FileInformation[], oldKey: string, newKey: string): FileInformation[] => {\n    const unique = isFileKeyUnique(existingFiles, newKey);\n    let updatedFiles: FileInformation[] = [];\n    existingFiles.forEach(file => {\n        if(unique && file.key === oldKey){\n            updatedFiles.push({\n                ...file,\n                key: newKey,\n                modified: +Moment(),\n            })\n        }else{\n            updatedFiles.push(file);\n        }\n    });\n    return updatedFiles;\n}\n\nconst renameFolder = (existingFiles: FileInformation[], oldKey: string, newKey: string): FileInformation[] => {\n    const unique = isFolderKeyUnique(existingFiles, newKey);\n    let updatedFiles: FileInformation[] = [];\n    existingFiles.forEach(file => {\n        if (unique && (file.key.substr(0, oldKey.length) === oldKey))\n        {\n            updatedFiles.push({\n                ...file,\n                key: file.key.replace(oldKey, newKey),\n                modified: +Moment(),\n            })\n        } else {\n            updatedFiles.push(file)\n        }\n    })\n    return  updatedFiles;\n}\n\nconst isFileKeyUnique = (existingFiles: FileInformation[], keyOfTheFile: string): boolean => {\n    let unique = true;\n    existingFiles.forEach(file => {\n        if(file.key === keyOfTheFile)\n        {\n            unique = false;\n            return;\n        }\n    })\n    return unique;\n}\n\nconst isFolderKeyUnique = (existingFiles: FileInformation[], keyOfTheFolder: string): boolean => {\n    let unique = true;\n    existingFiles.forEach(file => {\n        if (file.key.substr(0, keyOfTheFolder.length) === keyOfTheFolder)\n        {\n            unique = false;\n        }\n    })\n    return unique;\n}\n\nconst shouldBeFolderDeleted = (existingFileKey: string, keysOfFoldersToBeDeleted: string[]): boolean => {\n    let shouldDelete = false;\n    keysOfFoldersToBeDeleted.forEach((keyOfFolderToBeDeleted) => {\n        if (existingFileKey.substr(0, keyOfFolderToBeDeleted.length) === keyOfFolderToBeDeleted)\n        {\n            shouldDelete = true;\n            return;\n        }\n    });\n    return shouldDelete;\n}\n\nconst shouldBeFileDeleted = (existingFileKey: string, keysOfFilesToBeDeleted: string[]): boolean => {\n    let shouldDelete = false;\n    keysOfFilesToBeDeleted.forEach((keyOfFileToBeDeleted) => {\n        if (keyOfFileToBeDeleted === keyOfFileToBeDeleted)\n        {\n            shouldDelete = true;\n            return;\n        }\n    });\n    return shouldDelete;\n}\n\nexport default {getUniqueAddedFiles, deleteSelectedFolders, deleteSelectedFile, renameFile, renameFolder};"]},"metadata":{},"sourceType":"module"}