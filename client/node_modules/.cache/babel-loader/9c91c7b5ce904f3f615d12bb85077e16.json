{"ast":null,"code":"import Moment from \"moment\";\n\nconst getUniqueAddedFiles = (existingFiles, addedFiles, prefix) => {\n  const newFiles = addedFiles.map(file => {\n    let newKey = prefix;\n\n    if (prefix !== '' && prefix.substring(prefix.length - 1) !== '/') {\n      newKey += '/';\n    }\n\n    newKey += file.name;\n    return {\n      key: newKey,\n      size: file.size,\n      modified: +Moment().unix(),\n      data: file\n    };\n  });\n  const uniqueNewFiles = [];\n  newFiles.map(newFile => {\n    let fileAlreadyExists = false;\n    existingFiles.map(existingFile => {\n      if (existingFile.key === newFile.key) {\n        fileAlreadyExists = true;\n      }\n    });\n\n    if (!fileAlreadyExists) {\n      uniqueNewFiles.push(newFile);\n    }\n  });\n  return uniqueNewFiles;\n};\n\nconst deleteSelectedFolders = (existingFiles, keysOfFoldersToBeDeleted) => {\n  return existingFiles.filter(file => !shouldBeDeleted(file.key, keysOfFoldersToBeDeleted));\n};\n\nconst shouldBeDeleted = (existingFileKey, keysOfFoldersToBeDeleted) => {\n  let shouldDelete = false;\n  keysOfFoldersToBeDeleted.forEach(keyOfFolderToBeDeleted => {\n    if (existingFileKey.substr(0, keyOfFolderToBeDeleted.length) === keyOfFolderToBeDeleted) {\n      shouldDelete = true;\n      return;\n    }\n  });\n  return shouldDelete;\n};\n\nexport default {\n  getUniqueAddedFiles,\n  deleteSelectedFolders\n};","map":{"version":3,"sources":["/Users/jan/dev/thesis/ml_runner/react/ml-runner/src/components/dataset/DatasetUtility.ts"],"names":["Moment","getUniqueAddedFiles","existingFiles","addedFiles","prefix","newFiles","map","file","newKey","substring","length","name","key","size","modified","unix","data","uniqueNewFiles","newFile","fileAlreadyExists","existingFile","push","deleteSelectedFolders","keysOfFoldersToBeDeleted","filter","shouldBeDeleted","existingFileKey","shouldDelete","forEach","keyOfFolderToBeDeleted","substr"],"mappings":"AACA,OAAOA,MAAP,MAAmB,QAAnB;;AAEA,MAAMC,mBAAmB,GAAG,CAACC,aAAD,EAAmCC,UAAnC,EAAuDC,MAAvD,KAA6F;AACrH,QAAMC,QAAgC,GAAGF,UAAU,CAACG,GAAX,CAAgBC,IAAD,IACxD;AACI,QAAIC,MAAM,GAAGJ,MAAb;;AACA,QAAIA,MAAM,KAAK,EAAX,IAAiBA,MAAM,CAACK,SAAP,CAAiBL,MAAM,CAACM,MAAP,GAAgB,CAAjC,MAAwC,GAA7D,EACA;AACIF,MAAAA,MAAM,IAAI,GAAV;AACH;;AACDA,IAAAA,MAAM,IAAID,IAAI,CAACI,IAAf;AACA,WAAO;AACHC,MAAAA,GAAG,EAAEJ,MADF;AAEHK,MAAAA,IAAI,EAAEN,IAAI,CAACM,IAFR;AAGHC,MAAAA,QAAQ,EAAE,CAACd,MAAM,GAAGe,IAAT,EAHR;AAIHC,MAAAA,IAAI,EAAET;AAJH,KAAP;AAMH,GAdwC,CAAzC;AAgBA,QAAMU,cAAsC,GAAG,EAA/C;AAEAZ,EAAAA,QAAQ,CAACC,GAAT,CAAcY,OAAD,IACb;AACI,QAAIC,iBAAiB,GAAG,KAAxB;AACAjB,IAAAA,aAAa,CAACI,GAAd,CAAmBc,YAAD,IAClB;AACI,UAAIA,YAAY,CAACR,GAAb,KAAqBM,OAAO,CAACN,GAAjC,EACA;AACIO,QAAAA,iBAAiB,GAAG,IAApB;AACH;AACJ,KAND;;AAOA,QAAI,CAACA,iBAAL,EACA;AACIF,MAAAA,cAAc,CAACI,IAAf,CAAoBH,OAApB;AACH;AACJ,GAdD;AAgBA,SAAOD,cAAP;AACH,CApCD;;AAsCA,MAAMK,qBAAqB,GAAG,CAACpB,aAAD,EAAmCqB,wBAAnC,KAA6F;AACvH,SAAOrB,aAAa,CAACsB,MAAd,CAAqBjB,IAAI,IAAI,CAACkB,eAAe,CAAClB,IAAI,CAACK,GAAN,EAAWW,wBAAX,CAA7C,CAAP;AACH,CAFD;;AAIA,MAAME,eAAe,GAAG,CAACC,eAAD,EAA0BH,wBAA1B,KAA0E;AAC9F,MAAII,YAAY,GAAG,KAAnB;AACAJ,EAAAA,wBAAwB,CAACK,OAAzB,CAAkCC,sBAAD,IAA4B;AACzD,QAAIH,eAAe,CAACI,MAAhB,CAAuB,CAAvB,EAA0BD,sBAAsB,CAACnB,MAAjD,MAA6DmB,sBAAjE,EACA;AACIF,MAAAA,YAAY,GAAG,IAAf;AACA;AACH;AACJ,GAND;AAOA,SAAOA,YAAP;AACH,CAVD;;AAYA,eAAe;AAAC1B,EAAAA,mBAAD;AAAsBqB,EAAAA;AAAtB,CAAf","sourcesContent":["import {FileInformation} from \"../../types\";\nimport Moment from \"moment\";\n\nconst getUniqueAddedFiles = (existingFiles: FileInformation[], addedFiles: File[], prefix: string): FileInformation[] => {\n    const newFiles: Array<FileInformation> = addedFiles.map((file) =>\n    {\n        let newKey = prefix\n        if (prefix !== '' && prefix.substring(prefix.length - 1) !== '/')\n        {\n            newKey += '/'\n        }\n        newKey += file.name\n        return {\n            key: newKey,\n            size: file.size,\n            modified: +Moment().unix(),\n            data: file\n        }\n    })\n\n    const uniqueNewFiles: Array<FileInformation> = [];\n\n    newFiles.map((newFile) =>\n    {\n        let fileAlreadyExists = false;\n        existingFiles.map((existingFile) =>\n        {\n            if (existingFile.key === newFile.key)\n            {\n                fileAlreadyExists = true;\n            }\n        })\n        if (!fileAlreadyExists)\n        {\n            uniqueNewFiles.push(newFile);\n        }\n    })\n\n    return uniqueNewFiles;\n}\n\nconst deleteSelectedFolders = (existingFiles: FileInformation[], keysOfFoldersToBeDeleted: string[]): FileInformation[] => {\n    return existingFiles.filter(file => !shouldBeDeleted(file.key, keysOfFoldersToBeDeleted));\n}\n\nconst shouldBeDeleted = (existingFileKey: string, keysOfFoldersToBeDeleted: string[]): boolean => {\n    let shouldDelete = false;\n    keysOfFoldersToBeDeleted.forEach((keyOfFolderToBeDeleted) => {\n        if (existingFileKey.substr(0, keyOfFolderToBeDeleted.length) === keyOfFolderToBeDeleted)\n        {\n            shouldDelete = true;\n            return;\n        }\n    });\n    return shouldDelete;\n}\n\nexport default {getUniqueAddedFiles, deleteSelectedFolders};"]},"metadata":{},"sourceType":"module"}